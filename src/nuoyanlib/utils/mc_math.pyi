# -*- coding: utf-8 -*-
# =================================================
#  ⠀
#   Copyright (c) 2025 Nuoyan
#  ⠀
#   Author: Nuoyan <https://github.com/charminglee>
#   Email : 1279735247@qq.com
#   Date  : 2025-12-22
#  ⠀
# =================================================


from typing import Iterable, Literal, Union, Optional, Callable, Tuple, Sequence, overload
from mod.common.minecraftEnum import Facing
from ..core._types._typing import FTuple2, FTuple3, ITuple3, ITuple2


__Pos3OrEntityId = Union[FTuple3, str]
__Pos2OrEntityId = Union[FTuple2, str]


_INF: float
_NAN: float
_ZERO_EPS: float
def _get_pos(target: __Pos3OrEntityId, is_client: Optional[bool] = None) -> FTuple3: ...
def _get_dim(entity_id: str) -> int: ...
@overload
def manhattan_distance(target1: __Pos3OrEntityId, target2: __Pos3OrEntityId) -> float: ...
@overload
def manhattan_distance(target1: __Pos2OrEntityId, target2: __Pos2OrEntityId) -> float: ...
@overload
def _dist_square(p1: FTuple3, p2: FTuple3) -> float: ...
@overload
def _dist_square(p1: FTuple2, p2: FTuple2) -> float: ...
@overload
def _dist(p1: FTuple3, p2: FTuple3) -> float: ...
@overload
def _dist(p1: FTuple2, p2: FTuple2) -> float: ...
@overload
def distance2nearest_entity(target: FTuple3, dim: int) -> float: ...
@overload
def distance2nearest_entity(target: str) -> float: ...
@overload
def distance2nearest_player(target: FTuple3, dim: int) -> float: ...
@overload
def distance2nearest_player(target: str) -> float: ...
def distance2line(pos: __Pos3OrEntityId, line_pos1: FTuple3, line_pos2: FTuple3) -> float: ...
@overload
def distance_square(target1: __Pos3OrEntityId, target2: __Pos3OrEntityId) -> float: ...
@overload
def distance_square(target1: __Pos2OrEntityId, target2: __Pos2OrEntityId) -> float: ...
@overload
def distance(target1: __Pos3OrEntityId, target2: __Pos3OrEntityId) -> float: ...
@overload
def distance(target1: __Pos2OrEntityId, target2: __Pos2OrEntityId) -> float: ...
def chunk_pos(pos: FTuple3) -> Optional[ITuple2]: ...
def polar_coord(coord: FTuple2, rad: bool = False, origin: FTuple2 = (0, 0)) -> FTuple2: ...
def cartesian_coord(coord: FTuple2, rad: bool = False, origin: FTuple2 = (0, 0)) -> FTuple2: ...
@overload
def relative_pos(pos: FTuple3, basis: FTuple3) -> Optional[FTuple3]: ...
@overload
def relative_pos(pos: FTuple2, basis: FTuple2) -> Optional[FTuple2]: ...
@overload
def absolute_pos(pos: FTuple3, basis: FTuple3) -> Optional[FTuple3]: ...
@overload
def absolute_pos(pos: FTuple2, basis: FTuple2) -> Optional[FTuple2]: ...
def screen_pos(
    pos: FTuple3,
    world_basis: FTuple3,
    screen_basis: FTuple2 = (0, 0),
    scale: float = 1,
    offset: FTuple2 = (0, 0),
    rotation: float = 0,
    rad: bool = False,
) -> Optional[FTuple2]: ...
@overload
def box_min_max(pos1: FTuple3, pos2: FTuple3) -> Optional[Tuple[FTuple3, FTuple3]]: ...
@overload
def box_min_max(pos1: FTuple2, pos2: FTuple2) -> Optional[Tuple[FTuple2, FTuple2]]: ...
def pos_entity_facing(
    entity_id: str,
    dist: float,
    use_0yaw: bool = False,
    height_offset: float = 0,
) -> Optional[FTuple3]: ...
def pos_block_facing(pos: FTuple3, face: int = Facing.North, dist: float = 1.0) -> Optional[FTuple3]: ...
def pos_forward_rot(pos: FTuple3, rot: FTuple2, dist: float) -> Optional[FTuple3]: ...
@overload
def pos_floor(pos: FTuple3) -> Optional[ITuple3]: ...
@overload
def pos_floor(pos: FTuple2) -> Optional[ITuple2]: ...
@overload
def pos_floor(pos: Iterable[float]) -> Union[ITuple3, ITuple2, None]: ...
def pos_rotate(pos: FTuple2, angle: float, basis: FTuple2 = (0, 0), rad: bool = False) -> Optional[FTuple2]: ...
@overload
def midpoint(pos1: FTuple3, pos2: FTuple3) -> Optional[FTuple3]: ...
@overload
def midpoint(pos1: FTuple2, pos2: FTuple2) -> Optional[FTuple2]: ...
@overload
def box_center(pos1: FTuple3, pos2: FTuple3) -> Optional[FTuple3]: ...
@overload
def box_center(pos1: FTuple2, pos2: FTuple2) -> Optional[FTuple2]: ...
def ray_box_intersection(
    start_pos: FTuple3,
    ray_dir: FTuple3,
    length: float,
    aabb_center: FTuple3,
    aabb_size: FTuple3,
    handle_inside: Literal["none", "start", "exit"] = "none",
) -> Optional[FTuple3]: ...
def is_in_sphere(target: __Pos3OrEntityId, r: float, center: FTuple3) -> bool: ...
def is_in_cylinder(target: __Pos3OrEntityId, r: float, center1: FTuple3, center2: FTuple3) -> bool: ...
def is_in_sector(target: __Pos3OrEntityId, r: float, h: float, angle: float, center: FTuple3, direction: FTuple3) -> bool: ...
@overload
def is_in_box(target: __Pos3OrEntityId, pos1: FTuple3, pos2: FTuple3, ignore_y: bool = False) -> bool: ...
@overload
def is_in_box(target: __Pos2OrEntityId, pos1: FTuple2, pos2: FTuple2, ignore_y: bool = False) -> bool: ...
@overload
def fpp_camera_rot(rot: FTuple3) -> Optional[FTuple3]: ...
@overload
def fpp_camera_rot(rot: FTuple2) -> Optional[FTuple2]: ...
@overload
def tpp_camera_rot(rot: FTuple3) -> Optional[FTuple3]: ...
@overload
def tpp_camera_rot(rot: FTuple2) -> Optional[FTuple2]: ...
def rot_look_at(start: FTuple3, end: FTuple3) -> Optional[FTuple2]: ...
def angle_normalize(angle: float) -> float: ...
def bezier_curve(control_points: Sequence[FTuple3], t: float) -> FTuple3: ...
def catmull_rom(p0: FTuple3, p1: FTuple3, p2: FTuple3, p3: FTuple3, t: float, alpha: float = 0.5) -> FTuple3: ...
def lerp(a: float, b: float, t: float) -> float: ...
def range_map(
    x: float,
    output_range: FTuple2,
    input_range: FTuple2 = [0, 1], # noqa
    interp: Optional[Callable[[float], float]] = None,
) -> float: ...
def clamp(x: float, min_value: float, max_value: float) -> float: ...
def probability(p: float) -> bool: ...
@overload
def box_max_edge_len(pos1: FTuple3, pos2: FTuple3) -> float: ...
@overload
def box_max_edge_len(pos1: FTuple2, pos2: FTuple2) -> float: ...
