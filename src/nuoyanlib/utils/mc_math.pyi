# -*- coding: utf-8 -*-
"""
| ====================================================
|
|   Copyright (c) 2025 Nuoyan
|
|   Author: `Nuoyan <https://github.com/charminglee>`_
|   Email : 1279735247@qq.com
|   Date  : 2025-12-15
|
| ====================================================
"""


from typing import Union, Optional, List, Dict, Callable, Tuple
from mod.common.minecraftEnum import Facing
from ..core._types._typing import FTuple2, FTuple3, FTuple, ITuple, ITuple2


__Pos3OrEntityId = Union[FTuple3, str]
__PosOrEntityId = Union[FTuple, str]


_INF: float
_NAN: float


def _to_pos(target: __Pos3OrEntityId) -> FTuple3: ...
def _get_dim(entity_id: str) -> int: ...
def distance2nearest_entity(target: __Pos3OrEntityId, dim: Optional[int] = None) -> float: ...
def distance2nearest_player(target: __Pos3OrEntityId, dim: Optional[int] = None) -> float: ...
def distance2line(pos: __Pos3OrEntityId, line_pos1: FTuple3, line_pos2: FTuple3) -> float: ...
def distance_square(pos1: FTuple, pos2: FTuple) -> float: ...
def distance(target1: __PosOrEntityId, target2: __PosOrEntityId) -> float: ...
def range_map(
    x: float,
    output_range: FTuple2,
    input_range: FTuple2 = (0, 1),
    func: Callable[[float], float] = lambda t: t,
) -> float: ...
def to_chunk_pos(pos: FTuple3) -> Optional[ITuple2]: ...
def aabb_min_max(pos1: FTuple3, pos2: FTuple3) -> Optional[Tuple[FTuple3, FTuple3]]: ...
def clamp(x: float, min_value: float, max_value: float) -> float: ...
def pos_block_facing(pos: FTuple3, face: int = Facing.North, dist: float = 1.0) -> Optional[FTuple3]: ...
def to_polar_coordinate(coordinate: FTuple2, rad: bool = False, origin: FTuple2 = (0, 0)) -> FTuple2: ...
def to_cartesian_coordinate(coordinate: FTuple2, rad: bool = False, origin: FTuple2 = (0, 0)) -> FTuple2: ...
def probability(p: float) -> bool: ...
def pos_floor(pos: FTuple) -> ITuple: ...
def to_relative_pos(entity_pos1: FTuple3, entity_pos2: FTuple3) -> Optional[FTuple3]: ...
def to_screen_pos(
    entity_pos: FTuple3,
    center_pos: FTuple3,
    screen_size: int,
    max_distance: int,
    ui_size: int,
    player_rot: float,
) -> Optional[FTuple2]: ...
def pos_rotate(angle: float, pos: FTuple2) -> Optional[FTuple2]: ...
def midpoint(first_point: FTuple, second_point: FTuple) -> FTuple: ...
def camera_rot_p2p(pos1: FTuple3, pos2: FTuple3) -> Optional[FTuple2]: ...
def pos_entity_facing(
    entity_id: str,
    dist: float,
    use_0yaw: bool = False,
    height_offset: float = 0.0,
) -> Optional[FTuple3]: ...
def pos_forward_rot(pos: FTuple3, rot: FTuple2, dist: float) -> Optional[FTuple3]: ...
def n_quantiles_index_list(n: int, data: Union[tuple, list, set]) -> List[int]: ...
def cube_center(start_pos: FTuple3, end_pos: FTuple3) -> Optional[FTuple3]: ...
def cube_longest_side_len(start_pos: FTuple3, end_pos: FTuple3) -> float: ...
def is_in_cylinder(pos: FTuple3, r: float, center1: FTuple3, center2: FTuple3) -> bool: ...
def is_in_sector(pos: FTuple3, r: float, angle: float, center: FTuple3, direction: FTuple3) -> bool: ...
def is_in_cube(target: __Pos3OrEntityId, pos1: FTuple3, pos2: FTuple3, ignore_y: bool = False) -> bool: ...
def rot_diff(r1: float, r2: float) -> float: ...
def ray_aabb_intersection(
    ray_start_pos: FTuple3,
    ray_dir: FTuple3,
    length: float,
    cube_center_pos: FTuple3,
    cube_size: FTuple3,
) -> Optional[FTuple3]: ...
def get_blocks_by_ray(
    start_pos: FTuple3,
    direction: FTuple3,
    length: float,
    dimension: int = 0,
    count: int = 0,
    filter_blocks: Optional[List[str]] = None,
) -> List[Dict[str, Union[str, int, tuple]]]: ...
