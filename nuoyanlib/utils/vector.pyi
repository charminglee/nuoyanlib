# -*- coding: utf-8 -*-
# ====================================================
#
#   Copyright (c) 2023 Nuoyan
#   nuoyanlib is licensed under Mulan PSL v2.
#   You can use this software according to the terms and conditions of the Mulan PSL v2.
#   You may obtain a copy of Mulan PSL v2 at:
#            http://license.coscl.org.cn/MulanPSL2
#   THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
#   See the Mulan PSL v2 for more details.
#
#   Author        : 诺言Nuoyan
#   Email         : 1279735247@qq.com
#   Gitee         : https://gitee.com/charming-lee
#   Last Modified : 2024-01-30

# ====================================================


from mod.common.utils.mcmath import Vector3
from .._core._typing import FTuple3, FTuple2, Vector, Matrix, VectorNotList


def _to_Vector3(vec: Vector) -> Vector3: ...
def vec_entity_left(entity_id: str, ret_Vector3: bool = False) -> VectorNotList: ...
def vec_entity_right(entity_id: str, ret_Vector3: bool = False) -> VectorNotList: ...
def vec_entity_front(entity_id: str, ignore_y: bool = False, ret_Vector3: bool = False) -> VectorNotList: ...
def vec_entity_back(entity_id: str, ignore_y: bool = False, ret_Vector3: bool = False) -> VectorNotList: ...
def _convert_return_vec(input_vec: Vector, output_vec: Vector, convert: bool) -> Vector: ...
def vec_normalize(vec: Vector, convert_vec: bool = False) -> Vector: ...
def vec_rot_p2p(pos1: FTuple3, pos2: FTuple3) -> FTuple2: ...
def vec_p2p(pos1: FTuple3, pos2: FTuple3, ret_Vector3: bool = False) -> VectorNotList: ...
def vec_length(vec: Vector) -> float: ...
def vec_angle(vec1: Vector, vec2: Vector) -> float: ...
def _matrix_mult(matrix1: Matrix, matrix2: Matrix) -> Matrix: ...
def vec_euler_rotate(
    vec: Vector,
    x_angle: float = 0.0,
    y_angle: float = 0.0,
    z_angle: float = 0.0,
    order: str = "zyx",
    convert_vec: bool = False,
) -> Vector: ...
def vec_rotate_around(v: Vector, u: Vector, angle: float, convert_vec: bool = False) -> Vector: ...
def outgoing_vec(vec: Vector, normal: Vector, convert_vec: bool = False) -> Vector: ...
def vec_composite(convert_vec: bool, vec: Vector, *more_vec: Vector) -> Vector: ...
def vec_scale(vec: Vector, scale: float, convert_vec: bool = False) -> Vector: ...
